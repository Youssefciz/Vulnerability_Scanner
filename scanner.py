import aiohttp
import asyncio

async def fetch(session, url, headers=None):
    try:
        async with session.get(url, headers=headers, timeout=10) as response:
            return await response.text()
    except Exception as e:
        return f"Error fetching {url}: {str(e)}"

# SQL Injection Scan
async def scan_for_sql_injection(url):
    sql_payloads = ["' OR '1'='1", "' OR '1'='0", "' OR 'x'='x"]
    async with aiohttp.ClientSession() as session:
        for payload in sql_payloads:
            test_url = f"{url}?id={payload}"
            response_text = await fetch(session, test_url)
            if "sql" in response_text.lower():
                return {
                    "name": "SQL Injection",
                    "payload": payload,
                    "severity": "High",
                    "details": f"SQL Injection allows attackers to execute arbitrary SQL code on a database at {url}.",
                    "remediation": "Use parameterized queries or prepared statements to prevent SQL Injection."
                }
    return None

# Cross-Site Scripting (XSS) Scan
async def scan_for_xss(url):
    xss_payloads = ["<script>alert('XSS')</script>", "<img src='x' onerror='alert(1)'>"]
    async with aiohttp.ClientSession() as session:
        for payload in xss_payloads:
            test_url = f"{url}?q={payload}"
            response_text = await fetch(session, test_url)
            if payload in response_text:
                return {
                    "name": "Cross-Site Scripting (XSS)",
                    "payload": payload,
                    "severity": "Medium",
                    "details": f"XSS allows attackers to inject malicious scripts into webpages viewed by other users at {url}.",
                    "remediation": "Use output encoding and Content Security Policy (CSP) to prevent XSS."
                }
    return None

# Directory Traversal Scan
async def scan_for_directory_traversal(url):
    traversal_payloads = ["../", "../../", "../../../"]
    async with aiohttp.ClientSession() as session:
        for payload in traversal_payloads:
            test_url = f"{url}/{payload}"
            response_text = await fetch(session, test_url)
            if "root:" in response_text.lower():
                return {
                    "name": "Directory Traversal",
                    "payload": payload,
                    "severity": "High",
                    "details": f"Directory Traversal allows attackers to access directories outside the web root at {url}.",
                    "remediation": "Validate and sanitize user input to prevent directory traversal."
                }
    return None

# HTTP Header Injection Scan
async def scan_for_http_header_injection(url):
    header_payloads = {"User-Agent": "BadBot"}
    async with aiohttp.ClientSession() as session:
        for header, value in header_payloads.items():
            response_text = await fetch(session, url, headers={header: value})
            if value.lower() in response_text.lower():
                return {
                    "name": "HTTP Header Injection",
                    "payload": value,
                    "severity": "Medium",
                    "details": f"HTTP Header Injection allows attackers to manipulate HTTP headers at {url}.",
                    "remediation": "Validate and sanitize HTTP header values."
                }
    return None

# Command Injection Scan
async def scan_for_command_injection(url):
    cmd_payloads = ["; ls", "| whoami", "`uname -a`"]
    async with aiohttp.ClientSession() as session:
        for payload in cmd_payloads:
            test_url = f"{url}?cmd={payload}"
            response_text = await fetch(session, test_url)
            if "root" in response_text.lower() or "admin" in response_text.lower():
                return {
                    "name": "Command Injection",
                    "payload": payload,
                    "severity": "Critical",
                    "details": f"Command Injection allows attackers to execute arbitrary commands on the server at {url}.",
                    "remediation": "Use parameterized commands and avoid directly passing user input to the shell."
                }
    return None

# Sensitive Data Exposure Scan
async def scan_for_sensitive_data_exposure(url):
    keywords = ["password", "secret", "key"]
    async with aiohttp.ClientSession() as session:
        response_text = await fetch(session, url)
        for keyword in keywords:
            if keyword in response_text.lower():
                return {
                    "name": "Sensitive Data Exposure",
                    "keyword": keyword,
                    "severity": "High",
                    "details": f"Sensitive data like '{keyword}' is exposed at {url}.",
                    "remediation": "Use encryption and secure storage practices to protect sensitive data."
                }
    return None

# Unrestricted File Upload Scan
async def scan_for_unrestricted_file_upload(url):
    file_payload = {'file': ('test.txt', 'This is a test file.')}
    async with aiohttp.ClientSession() as session:
        try:
            async with session.post(url, data=file_payload) as response:
                if response.status == 200:
                    return {
                        "name": "Unrestricted File Upload",
                        "severity": "High",
                        "details": f"The application at {url} may allow unrestricted file uploads.",
                        "remediation": "Validate file types and use secure storage to prevent malicious files from being uploaded."
                    }
        except Exception as e:
            return {
                "name": "File Upload Error",
                "severity": "Medium",
                "details": f"Error performing file upload: {str(e)}",
                "remediation": "Ensure proper file upload handling."
            }
    return None
